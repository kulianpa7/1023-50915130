<!DOCTYPE html>
<script src="https://cdn.jsdelivr.net/npm/sweetalert2@11"></script>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Two Player Arkanoid Game</title>
  <style>
    canvas {
      display: block;
      margin: 0 auto;
      background: #808080;
    }
    #gameMenu {
      text-align: center;
      margin-top: 50px;
    }
    #gameMenu button {
      padding: 10px 20px;
      margin: 5px;
      font-size: 16px;
    }
  </style>
</head>
<body>

<div id="gameMenu">
  <h1>雙人 Arkanoid 遊戲</h1>
  <p>選擇難度：</p>
  <button onclick="startGame('easy',brick1)">簡單</button>
  <button onclick="startGame('medium',brick1)">中等</button>
  <button onclick="startGame('hard',brick1)">困難</button>
</div>

<canvas id="arkanoid" width="1200" height="600" style="display:none;"></canvas>
<script src="brickarray.js"></script>
<script>
  let canvas, ctx;
  let ballRadius = 10;
  //---------------
  // 為玩家狀態添加軌跡數組
  //---------------
  let players = [
    { x: 0, y: 0, dx: 0, dy: 0, paddleX: 0, score: 0, lives: 0, trailPositions: [] },
    { x: 0, y: 0, dx: 0, dy: 0, paddleX: 0, score: 0, lives: 0, trailPositions: [] }
  ];

  let paddleHeight = 10, paddleWidth = 100;
  let rightPressed = [false, false], leftPressed = [false, false];
  let brickRowCount, brickColumnCount, brickWidth, brickHeight, brickPadding, brickOffsetTop, brickOffsetLeft;
  let bricks = [[], []]; // 為每個玩家創建獨立的磚塊數組
  let difficulty;
  let ballSpeed;
  let maxLives;
  
  //---------------
  // 新增軌跡相關參數配置
  //---------------
  const TRAIL_LENGTH = 10; // 軌跡長度
  const TRAIL_INTERVAL = 2; // 每隔幾幀記錄一次位置
  let frameCount = 0;

  // 音效（保持原有的音效設置）
  let backgroundMusic = new Audio('background.mp3');
  let hitSound = new Audio('hit.wav');
  let lifeLostSound = new Audio('life_lost.wav');
  let gameOverSound = new Audio('game_over.wav');
  let winSound = new Audio('win.wav');

  function startGame(selectedDifficulty,brick) {
    difficulty = selectedDifficulty;
    canvas = document.getElementById("arkanoid");
    ctx = canvas.getContext("2d");
    canvas.style.display = 'block';
    document.getElementById('gameMenu').style.display = 'none';

    // 根據難度設置遊戲參數
    if (difficulty === 'easy') {
      ballSpeed = 4;
      brickRowCount = 4;
      brickColumnCount = 6;
      maxLives = 5;
    } else if (difficulty === 'medium') {
      ballSpeed = 6;
      brickRowCount = 4;
      brickColumnCount = 6;
      maxLives = 3;
    } else if (difficulty === 'hard') {
      ballSpeed = 7;
      brickRowCount = 4;
      brickColumnCount = 6;
      maxLives = 2;
    }

    // 初始化兩個玩家的遊戲狀態
    for (let i = 0; i < 2; i++) {
      players[i].lives = maxLives;
      players[i].score = 0;
      // 設置初始球位置（左右兩邊）
      players[i].x = (i === 0) ? canvas.width / 4 : (canvas.width * 3) / 4;
      players[i].y = canvas.height - 30;
      players[i].dx = (i === 0) ? ballSpeed : -ballSpeed;
      players[i].dy = -ballSpeed;
      players[i].paddleX = (i === 0) ? 
        (canvas.width / 4 - paddleWidth / 2) : 
        (canvas.width * 3 / 4 - paddleWidth / 2);
      //---------------
      // 初始化軌跡數組
      //---------------
      players[i].trailPositions = [];
    }

    // 初始化磚塊參數
    brickWidth = 75;
    brickHeight = 20;
    brickPadding = 10;
    brickOffsetTop = 30;
    brickOffsetLeft = 30;
    initBricks(brick);

    // 添加事件監聽器
    document.addEventListener("keydown", keyDownHandler, false);
    document.addEventListener("keyup", keyUpHandler, false);

    // 播放背景音樂
    backgroundMusic.loop = true;
    backgroundMusic.play();

    // 開始遊戲循環
    draw();
  }
  //---------------
  // 新增軌跡更新函數
  //---------------
  function updateTrail(playerIndex) {
    const player = players[playerIndex];
    
    if (difficulty === 'easy' && frameCount % TRAIL_INTERVAL === 0) {
      player.trailPositions.push({x: player.x, y: player.y});
      if (player.trailPositions.length > TRAIL_LENGTH) {
        player.trailPositions.shift();
      }
    }
  }
    //---------------
  // 新增軌跡繪製函數
  //---------------
  function drawTrail(playerIndex) {
    const player = players[playerIndex];
    
    if (difficulty === 'easy') {
      player.trailPositions.forEach((pos, index) => {
        const opacity = (index + 1) / player.trailPositions.length;
        ctx.beginPath();
        ctx.arc(pos.x, pos.y, ballRadius * (opacity * 0.8), 0, Math.PI * 2);
        ctx.fillStyle = `rgba(${playerIndex === 0 ? '0, 149, 221' : '221, 149, 0'}, ${opacity * 0.5})`;
        ctx.fill();
        ctx.closePath();
      });
    }
  }
function initBricks(brick) {
    // 為每個玩家初始化磚塊
    for (let p = 0; p < 2; p++) {
        bricks[p] = [];
        for (let c = 0; c < brickColumnCount; c++) {
            bricks[p][c] = [];
            for (let r = 0; r < brickRowCount; r++) {
                // 從 brick1 物件中獲取相應難度的磚塊強度
                const brickStrength = brick[difficulty][r][c];
                bricks[p][c][r] = { x: 0, y: 0, strength: brickStrength }; // 每個磚塊的初始屬性
            }
        }
    }
}

  function keyDownHandler(e) {
    // 玩家1：A/D控制
    if (e.key === "d" || e.key === "D") {
      rightPressed[0] = true;
    } else if (e.key === "a" || e.key === "A") {
      leftPressed[0] = true;
    }
    // 玩家2：左右方向鍵控制
    if (e.key === "Right" || e.key === "ArrowRight") {
      rightPressed[1] = true;
    } else if (e.key === "Left" || e.key === "ArrowLeft") {
      leftPressed[1] = true;
    }
  }

  function keyUpHandler(e) {
    // 玩家1
    if (e.key === "d" || e.key === "D") {
      rightPressed[0] = false;
    } else if (e.key === "a" || e.key === "A") {
      leftPressed[0] = false;
    }
    // 玩家2
    if (e.key === "Right" || e.key === "ArrowRight") {
      rightPressed[1] = false;
    } else if (e.key === "Left" || e.key === "ArrowLeft") {
      leftPressed[1] = false;
    }
  }

  async function collisionDetection(playerIndex) {
    const player = players[playerIndex];
    const playerBricks = bricks[playerIndex];
    const playerHalf = (playerIndex === 0) ? 0 : canvas.width / 2;
    
    for(let c = 0; c < brickColumnCount; c++) {
      for(let r = 0; r < brickRowCount; r++) {
        let b = playerBricks[c][r];
        if(b.strength > 0) {
          if(player.x > b.x && player.x < b.x + brickWidth && 
             player.y > b.y && player.y < b.y + brickHeight) {
            player.dy = -player.dy;
            b.strength--;
            player.score += 10;
            hitSound.play();
            if(allBricksCleared(playerIndex)) {
              winSound.play();
              // 顯示玩家獲勝
              await showPlayerWinAlert(i, players[i].score, true);
              document.location.reload();
            }
          }
        }
      }
    }
  }

  function allBricksCleared(playerIndex) {
    for(let c = 0; c < brickColumnCount; c++) {
      for(let r = 0; r < brickRowCount; r++) {
        if(bricks[playerIndex][c][r].strength > 0) {
          return false;
        }
      }
    }
    return true;
  }
//---------------
  // 修改球的繪製函數，加入軌跡
  //---------------
  function drawBall(playerIndex) {
    const player = players[playerIndex];
    // 先繪製軌跡
    drawTrail(playerIndex);
    // 再繪製球
    ctx.beginPath();
    ctx.arc(player.x, player.y, ballRadius, 0, Math.PI*2);
    ctx.fillStyle = playerIndex === 0 ? "#0095DD" : "#DD9500";
    ctx.fill();
    ctx.closePath();
  }


  function drawPaddle(playerIndex) {
    const player = players[playerIndex];
    ctx.beginPath();
    ctx.rect(player.paddleX, canvas.height - paddleHeight - 10, 
             paddleWidth, paddleHeight);
    ctx.fillStyle = playerIndex === 0 ? "#0095DD" : "#DD9500";
    ctx.fill();
    ctx.closePath();
  }

  function drawBricks(playerIndex) {
    const offset = playerIndex === 0 ? 0 : canvas.width / 2;
    for(let c = 0; c < brickColumnCount; c++) {
      for(let r = 0; r < brickRowCount; r++) {
        if(bricks[playerIndex][c][r].strength > 0) {
          let brickX = (c * (brickWidth + brickPadding)) + brickOffsetLeft + offset;
          let brickY = (r * (brickHeight + brickPadding)) + brickOffsetTop;
          bricks[playerIndex][c][r].x = brickX;
          bricks[playerIndex][c][r].y = brickY;
          
          ctx.beginPath();
          ctx.rect(brickX, brickY, brickWidth, brickHeight);
          
          // 根據磚塊強度設置顏色
          if(bricks[playerIndex][c][r].strength === 1) {
            ctx.fillStyle = playerIndex === 0 ? "#FF5733" : "#33FF57";
          } else if(bricks[playerIndex][c][r].strength === 2) {
            ctx.fillStyle = playerIndex === 0 ? "#C70039" : "#00C739";
          } else if(bricks[playerIndex][c][r].strength === 3) {
            ctx.fillStyle = playerIndex === 0 ? "#900C3F" : "#0C903F";
          }
          ctx.fill();
          ctx.closePath();

          // 顯示剩餘擊打次數
          ctx.fillStyle = "#FFFFFF";
          ctx.font = "16px Arial";
          ctx.fillText(bricks[playerIndex][c][r].strength, 
                      brickX + brickWidth / 2 - 5, 
                      brickY + brickHeight / 2 + 5);
        }
      }
    }
  }

  function drawScore() {
    ctx.font = "16px Arial";
    ctx.fillStyle = "#FFFFFF";
    // 玩家1分數
    ctx.fillText("玩家1分數: " + players[0].score, 8, 20);
    // 玩家2分數
    ctx.fillText("玩家2分數: " + players[1].score, canvas.width - 150, 20);
  }

  function drawLives() {
    ctx.font = "16px Arial";
    ctx.fillStyle = "#FFFFFF";
    // 玩家1生命
    ctx.fillText("玩家1生命: " + players[0].lives, 8, 40);
    // 玩家2生命
    ctx.fillText("玩家2生命: " + players[1].lives, canvas.width - 150, 40);
  }

  // 繪製分隔線
  function drawDivider() {
    ctx.beginPath();
    ctx.setLineDash([5, 15]);
    ctx.moveTo(canvas.width / 2, 0);
    ctx.lineTo(canvas.width / 2, canvas.height);
    ctx.strokeStyle = "#FFFFFF";
    ctx.stroke();
    ctx.setLineDash([]);
  }

  async function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    drawDivider();
    drawScore();
    drawLives();
    
    //---------------
    // 更新幀計數器
    //---------------
    frameCount++;
    // 為每個玩家更新遊戲狀態
    for (let i = 0; i < 2; i++) {
      const player = players[i];
      const halfWidth = canvas.width / 2;
      const playerHalf = i === 0 ? 0 : halfWidth;
      
      //---------------
      // 加入軌跡更新
      //---------------
      updateTrail(i);

      drawBall(i);
      drawPaddle(i);
      drawBricks(i);
      collisionDetection(i);

      // 水平邊界碰撞
      if (i === 0) {
        if (player.x + player.dx < ballRadius || 
            player.x + player.dx > halfWidth - ballRadius) {
          player.dx = -player.dx;
        }
      } else {
        if (player.x + player.dx < halfWidth + ballRadius || 
            player.x + player.dx > canvas.width - ballRadius) {
          player.dx = -player.dx;
        }
      }

      // 垂直邊界碰撞
      if(player.y + player.dy < ballRadius) {
        player.dy = -player.dy;
      } else if(player.y + player.dy > canvas.height - ballRadius - paddleHeight - 10) {
        if(player.x > player.paddleX && player.x < player.paddleX + paddleWidth) {
          player.dy = -player.dy;
          
          // 根據擊球位置調整反彈角度
          let hitPoint = (player.x - player.paddleX) / paddleWidth;
          player.dx = ballSpeed * (hitPoint - 0.5) * 2;
        } else {
          player.lives--;
          //---------------
          // 失去生命時清空軌跡
          //---------------
          player.trailPositions = [];
          lifeLostSound.play();
          if(!player.lives) {
            gameOverSound.play();
            // 檢查是否兩個玩家都結束了
            if (players[(i + 1) % 2].lives === 0) {
              let winner = players[0].score > players[1].score ? "玩家1" : 
                          players[1].score > players[0].score ? "玩家2" : "平局";
                // 顯示遊戲結束
                await showGameOverAlert(winner, players[0].score, players[1].score);
            } else {
                // 顯示單人遊戲結束
                await showSinglePlayerGameOver(i, player.score);
            }
            document.location.reload();
          } else {
            resetPlayerBall(i);
          }
        }
      }

      // 更新球的位置
      player.x += player.dx;
      player.y += player.dy;

      // 更新擋板位置
      if (rightPressed[i] && player.paddleX < (i === 0 ? halfWidth - paddleWidth : canvas.width - paddleWidth)) {
        player.paddleX += 7;
      } else if (leftPressed[i] && player.paddleX > (i === 0 ? 0 : halfWidth)) {
        player.paddleX -= 7;
      }
    }

    // 檢查勝利條件
    await checkWinCondition();
    
    if (!gamePaused) {
      requestAnimationFrame(draw);
    }
  }

  // 重置球的位置
  function resetPlayerBall(playerIndex) {
    const player = players[playerIndex];
    player.x = playerIndex === 0 ? canvas.width / 4 : (canvas.width * 3) / 4;
    player.y = canvas.height - 30;
    player.dx = playerIndex === 0 ? ballSpeed : -ballSpeed;
    player.dy = -ballSpeed;
    player.paddleX = playerIndex === 0 ? 
      (canvas.width / 4 - paddleWidth / 2) : 
      (canvas.width * 3 / 4 - paddleWidth / 2);
  }
  async function showWinAlert(i) {
    await Swal.fire({
    title: `玩家 ${i + 1} 獲勝！`,
    text: `清除所有磚塊！\n得分：${players[i].score}`,
    icon: 'success',
    confirmButtonText: '確認'
    }).then((result) => {
        if (result.isConfirmed) {
            startGame(difficulty,brick2)
        }
    });
}
  // 檢查勝利條件
  async function checkWinCondition() {
    for (let i = 0; i < 2; i++) {
      if (allBricksCleared(i)) {
        winSound.play();
        await showWinAlert(i);
        
        return;
      }
    }
  }

  // 添加暫停功能
  let gamePaused = false;
  document.addEventListener('keydown', function(e) {
    if (e.key === 'p' || e.key === 'P') {
      gamePaused = !gamePaused;
      if (gamePaused) {
        backgroundMusic.pause();
        ctx.fillStyle = "rgba(0, 0, 0, 0.5)";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.font = "30px Arial";
        ctx.fillStyle = "#FFFFFF";
        ctx.textAlign = "center";
        ctx.fillText("遊戲暫停", canvas.width / 2, canvas.height / 2);
        ctx.font = "20px Arial";
        ctx.fillText("按 P 繼續", canvas.width / 2, canvas.height / 2 + 40);
      } else {
        backgroundMusic.play();
        draw();
      }
    }
  });

  // 添加遊戲說明
  async function showInstructions() {
    const instructions = `
      遊戲說明：
      玩家1 控制：
      - A：向左移動
      - D：向右移動

      玩家2 控制：
      - 左方向鍵：向左移動
      - 右方向鍵：向右移動

      其他控制：
      - P：暫停/繼續遊戲

      目標：
      - 清除所有磚塊
      - 保持球不落地
      - 磚塊需要被擊中指定次數才會消失
    `;
    // 顯示遊戲規則
    showInstructions();
  }

  // 在開始遊戲前添加說明按鈕
  window.onload = function() {
    const instructionButton = document.createElement('button');
    instructionButton.textContent = '遊戲說明';
    instructionButton.onclick = showInstructions;
    document.getElementById('gameMenu').appendChild(instructionButton);
  };
  </script>
<script>
    // 遊戲結束，玩家獲勝
async function showPlayerWinAlert(playerIndex, score, clearedAllBlocks = false) {
  const message = clearedAllBlocks 
    ? `清除所有磚塊！\n得分：${score}`
    : `得分：${score}`;
    
  await Swal.fire({
    title: `玩家 ${playerIndex + 1} 獲勝！`,
    text: message,
    icon: 'success',
    confirmButtonText: '確定',
    confirmButtonColor: '#3085d6',
    background: '#fff',
    customClass: {
      title: 'game-title',
      popup: 'game-popup'
    }
  });
}

async function showInstructions() {
    const instructions = `
      遊戲說明：
      玩家1 控制：
      - A：向左移動
      - D：向右移動

      玩家2 控制：
      - 左方向鍵：向左移動
      - 右方向鍵：向右移動

      其他控制：
      - P：暫停/繼續遊戲

      目標：
      - 清除所有磚塊
      - 保持球不落地
      - 磚塊需要被擊中指定次數才會消失
    `;
    
    // 顯示遊戲規則
    await Swal.fire({
        title: '遊戲說明',
        html: instructions,  // 使用 html 來顯示多行文本
        icon: 'info',
        confirmButtonText: '確認'
    });
}

// 遊戲結束，顯示雙方分數
async function showGameOverAlert(winner, player1Score, player2Score) {
  const isDrawGame = winner === "平局";
  
  await Swal.fire({
    title: '遊戲結束！',
    html: `
      ${isDrawGame ? "雙方平手！" : winner + "獲勝！"}<br>
      玩家1得分：${player1Score}<br>
      玩家2得分：${player2Score}
    `,
    icon: isDrawGame ? 'info' : 'success',
    confirmButtonText: '確定',
    confirmButtonColor: '#3085d6',
    background: '#fff',
    customClass: {
      popup: 'game-popup'
    }
  });
}

// 單人遊戲結束
async function showSinglePlayerGameOver(playerIndex, score) {
  await Swal.fire({
    title: `玩家 ${playerIndex + 1} 遊戲結束！`,
    text: `得分：${score}`,
    icon: 'info',
    confirmButtonText: '確定',
    confirmButtonColor: '#3085d6',
    background: '#fff',
    customClass: {
      popup: 'game-popup'
    }
  });
}

// CSS 樣式
const styles = `
.game-popup {
  font-family: '微軟正黑體', sans-serif;
  border-radius: 15px;
}

.game-title {
  font-size: 1.8em;
  color: #2c3e50;
}
`;

// 將樣式加入到頁面
const styleSheet = document.createElement('style');
styleSheet.textContent = styles;
document.head.appendChild(styleSheet);
</script>
</body>
</html>